# 냄새와 휴리스틱

아래의 내용은 다양한 프로그램을 검토하고 리팩터링 하면서 만들었다. 프로그램을 수정할 때마다 나는 '왜?' 라고 자문한 다음 그 답을 기록했다. 코드를 읽으면서 나쁜 냄새를 정리하다보니 목록이 상당히 길어졌다.

(역주: 이 챕터가 책의 모든 요약과 같다고 느꼈습니다.)

## 목차

- [냄새와 휴리스틱](#냄새와-휴리스틱)
  - [목차](#목차)
  - [주석](#주석)
    - [C1: 부적절한 정보](#c1-부적절한-정보)
    - [C2: 쓸모 없는 주석](#c2-쓸모-없는-주석)
    - [C3: 중복된 주석](#c3-중복된-주석)
    - [C4: 성의 없는 주석](#c4-성의-없는-주석)
    - [C5: 주석 처리된 코드](#c5-주석-처리된-코드)
  - [환경](#환경)
    - [E1: 여러 단계로 빌드해야 한다](#e1-여러-단계로-빌드해야-한다)
    - [E2: 여러 단계로 테스트해야 한다](#e2-여러-단계로-테스트해야-한다)
  - [함수](#함수)
    - [F1: 너무 많은 인수](#f1-너무-많은-인수)
    - [F2: 출력 인수](#f2-출력-인수)
    - [F3: 플래그 인수](#f3-플래그-인수)
    - [F4: 죽은 함수](#f4-죽은-함수)
  - [일반](#일반)
    - [G1: 한 소스 파일에 여러 언어를 사용한다](#g1-한-소스-파일에-여러-언어를-사용한다)
    - [G2: 당연한 동작을 구현하지 않는다](#g2-당연한-동작을-구현하지-않는다)
    - [G3: 경계를 올바로 처리하지 않는다](#g3-경계를-올바로-처리하지-않는다)
    - [G4: 안전 절차 무시](#g4-안전-절차-무시)
    - [G5: 중복](#g5-중복)
    - [G6: 추상화 수준이 올바르지 못하다](#g6-추상화-수준이-올바르지-못하다)
    - [G7: 기초 클래스가 파생 클래스에 의존한다](#g7-기초-클래스가-파생-클래스에-의존한다)
    - [G8: 과도한 정보](#g8-과도한-정보)
    - [G9: 죽은 코드](#g9-죽은-코드)
    - [G10: 수직 분리](#g10-수직-분리)
    - [G11: 일관성 부족](#g11-일관성-부족)
    - [G12: 잡동사니](#g12-잡동사니)
    - [G13: 인위적 결합](#g13-인위적-결합)
    - [G14: 기능 욕심](#g14-기능-욕심)
    - [G15: 선택자 인수](#g15-선택자-인수)
    - [G16: 모호한 의도](#g16-모호한-의도)
    - [G17: 잘못 지운 책임](#g17-잘못-지운-책임)
    - [G18: 부적절한 static 함수](#g18-부적절한-static-함수)
    - [G19: 서술적 변수](#g19-서술적-변수)
    - [G20: 이름과 기능이 일치하는 함수](#g20-이름과-기능이-일치하는-함수)
    - [G21: 알고리즘을 이해하라](#g21-알고리즘을-이해하라)
    - [G22: 논리적 의존성은 물리적으로 드러내라](#g22-논리적-의존성은-물리적으로-드러내라)
    - [G23: If/Else, Switch/Case 보다는 다형성을 사용하라](#g23-ifelse-switchcase-보다는-다형성을-사용하라)
    - [G24: 표준 표기법을 따르라](#g24-표준-표기법을-따르라)
    - [G25: 매직 숫자는 명명된 상수로 교체하라](#g25-매직-숫자는-명명된-상수로-교체하라)
    - [G26: 정확하라](#g26-정확하라)
    - [G27: 관례보다 구조를 사용하라](#g27-관례보다-구조를-사용하라)
    - [G28: 조건을 캡슐화하라](#g28-조건을-캡슐화하라)
    - [G29: 부정 조건은 피하라](#g29-부정-조건은-피하라)
    - [G30: 함수은 한 가지만 해야 한다](#g30-함수은-한-가지만-해야-한다)
    - [G31: 숨겨진 시간적인 결합](#g31-숨겨진-시간적인-결합)
    - [G32: 일관성을 유지하라](#g32-일관성을-유지하라)
    - [G33: 경계 조건을 캡슐화하라](#g33-경계-조건을-캡슐화하라)
    - [G34: 함수는 추상화 수준을 한 단계만 내려가야 한다](#g34-함수는-추상화-수준을-한-단계만-내려가야-한다)
    - [G35: 설정 정보는 최상위 단계에 둬라](#g35-설정-정보는-최상위-단계에-둬라)
    - [G36: 추이적 탐색을 피하라](#g36-추이적-탐색을-피하라)
  - [Java](#java)
    - [J1: 긴 import 목록을 피하고 와일드카드를 사용하라](#j1-긴-import-목록을-피하고-와일드카드를-사용하라)
    - [J2: 상수는 상속하지 않는다](#j2-상수는-상속하지-않는다)
    - [J3: 상수 대 Enum](#j3-상수-대-enum)
  - [이름](#이름)
    - [N1: 서술적인 이름을 사용하라](#n1-서술적인-이름을-사용하라)
    - [N2: 적절한 추상화 수준에서 이름을 선택하라](#n2-적절한-추상화-수준에서-이름을-선택하라)
    - [N3: 가능하다면 표준 명명법을 사용하라](#n3-가능하다면-표준-명명법을-사용하라)
    - [N4: 명확한 이름](#n4-명확한-이름)
    - [N5: 긴 범위는 긴 이름을 사용하라](#n5-긴-범위는-긴-이름을-사용하라)
    - [N6: 인코딩을 피하라](#n6-인코딩을-피하라)
    - [N7: 이름으로 부수 효과를 설명하라](#n7-이름으로-부수-효과를-설명하라)
  - [테스트](#테스트)
    - [T1: 불충분한 테스트](#t1-불충분한-테스트)
    - [T2: 커버리지 도구를 사용하라!](#t2-커버리지-도구를-사용하라)
    - [T3: 사소한 테스트를 건너뛰지 마라](#t3-사소한-테스트를-건너뛰지-마라)
    - [T4: 무시한 테스트는 모호함을 뜻한다](#t4-무시한-테스트는-모호함을-뜻한다)
    - [T5: 경계 조건을 테스트하라](#t5-경계-조건을-테스트하라)
    - [T6: 버그 주변은 철저히 테스트하라](#t6-버그-주변은-철저히-테스트하라)
    - [T7: 실패 패턴을 살펴라](#t7-실패-패턴을-살펴라)
    - [T8: 테스트 커버리지 패턴을 살펴라](#t8-테스트-커버리지-패턴을-살펴라)
    - [T9: 테스트는 빨라야 한다](#t9-테스트는-빨라야-한다)

## 주석
### C1: 부적절한 정보
다른 시스템(소스코드 관리, 버그 추적 시스템, 이슈 추적 시스템, 기타 기록 관리 시스템에) 저장할 정보는 지워라

### C2: 쓸모 없는 주석
오래된 주석, 엉뚱한 주석, 잘못된 주석

### C3: 중복된 주석
코드를 설명하는 주석

### C4: 성의 없는 주석
주석을 공들여 달것이 아니면 달지마라.

### C5: 주석 처리된 코드
지워라. 소스 코드 관리 시스템을 믿어라.

## 환경
### E1: 여러 단계로 빌드해야 한다
빌드는 한 단계로 끝나야 한다. 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.(빌드의 과정이 많다면 분명 빠트리고 치명적인 장애를 유발할 수 있다.)

### E2: 여러 단계로 테스트해야 한다
모든 단위 테스트는 한 명령으로 돌려야 한다. IDE에서 버튼 하나로 돌린다면 가장 이상적이다.

## 함수
### F1: 너무 많은 인수
인수는 작을수록 좋다. 아에 없으면 더 좋다. 넷 이상은 그 가치가 아주 의심스러우므로 최대한 피한다.

### F2: 출력 인수
일반적으로 독자는 인수를 입력으로 간주한다. 함수가 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경한다.

### F3: 플래그 인수
`boolean` 인수는 대놓고 함수가 여러 기능을 수행한다는 증거다.

### F4: 죽은 함수
아무도 안쓰는 함수는 삭제한다.

## 일반
### G1: 한 소스 파일에 여러 언어를 사용한다
`JSP` 파일은 `HTML`, `Java`, `JavaScript` 등 여러 언어가 가능하다. 소스 파일에서 언어 수와 범위를 최대한 줄여라.

### G2: 당연한 동작을 구현하지 않는다
최소 놀람 원칙<sup>The Principle of Least Surprises</sup>에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.

### G3: 경계를 올바로 처리하지 않는다
모든 경계 조건, 모든 구석진 곳, 모든 예외는 우아하고 직관적인 알고리즘을 좌초시킬 암초다. 스스로의 직관에 의존하지 마라. 모든 경계 조건을 테스트해라.

### G4: 안전 절차 무시
컴파일러의 경고를 무시하지마라. 실패하는 테스트 케이스를 일단 제껴두고 나중으로 미루는 행동은 신용카드가 공짜라는 생각과 다를바 없다.

### G5: 중복
DRY<sup>Don’t Repeat Yourself</sup> - 데이비드 토머스, 앤디 헌트

한 번, 단 한 번만<sup>Once and only once</sup> - 켄트 벡

중복 된 코드를 발견할 때마다 추상화의 기회로 간주하라. 하위 루틴이나 다른 클래스로 분리하라.
여러 모듈에서 일련의 `switch/case`나 `if/else`가 나오면 다형성<sup>polymorphism</sup>으로 대체해야 한다.
알고리즘이 유사하나 코드가 서로 다른 것도 중복이다. `Template Method Pattern`이나 `Strategy Pattern`을 사용해라.

### G6: 추상화 수준이 올바르지 못하다
추상화로 개념을 분리할 때는 철저해야 한다. 모든 저차원 개념음 파생 클래스로, 고차원 개념은 기초 클래스에 넣는다.

### G7: 기초 클래스가 파생 클래스에 의존한다
기초 클래스는 파생 클래스의 존재 자체를 몰라야 한다.

### G8: 과도한 정보
잘 정의된 `interface`는 많은 함수를 제공하지 않는다. 그래서 결합도<sup>coupling</sup>가 낮다. 부실하게 정의된 interface는 구질구질하다. 반드시 호출해야 하는 온갖 함수를제공한다. 그래서 결합도가 높다.

자료를 숨겨라. 유틸리티 함수를 숨겨라. 상수와 임시 변수를 숨겨라. 메서드나 인스턴스 변수가 넘쳐나는 클래스를 피하라. `protected` 변수나 함수를 마구 생성하지 마라. 정보를 제한해 결합도를 낮춰라.

### G9: 죽은 코드
실행되지 않는 코드는 제거하라. 불가능한 조건의 `if/switch` 문, `throw` 없는 `try` 문에서의 catch절.

### G10: 수직 분리
변수와 함수는 사용되는 위치에 가깝게 정의한다. 비공개 함수는 처음 호출되는 위치를 찾은 후 조금만 아래로 내려가면 쉽게 눈에 띄어야 한다.

### G11: 일관성 부족
최소 놀람 원칙을 기억해라. 표기법은 신중하게 선택하고 따른다. 변수이름, 구현 방법에 일관성을 유지해라.

### G12: 잡동사니
비어 있는 기본 생성자는 지워라. 사용하지 않는 변수, 함수, 쓸데없는 주석을 지워라.

### G13: 인위적 결합
`enum`은 클래스에 속할 이유가 없다. `public static` 함수도 특정 클래스에 속할 이유가 없다. 뚜렷한 목적없이 당장 편한 위치에(당연히 잘못된 위치에) 넣어버린 결과다. 시간을 들여서라도 올바른 위치를 고민하라.

### G14: 기능 욕심
클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스에 관심을 가져서는 안된다. 어쩔수 없는 경우에는 그 범위를 최소화 해라.

### G15: 선택자 인수
큰 함수를 작은 함수 여럿으로 쪼개지 않으려는 게으름의 소산이다. `bool`뿐만 아니라 `enum`, `int` 등으로 함수 동작을 제어하려하는 것은 바람직하지 않다.

### G16: 모호한 의도
짧고 빽빽한 코드는 의도를 파악하기 힘들다. 코드를 짤 때는 의도를 최대한 분명히 밝힌다.

### G17: 잘못 지운 책임
코드 배치 위치를 결정하는 것은 굉장히 중요하다. 때로는 개발자가 독자에게 직관적인 위치가 아닌 개발자에게 편한 위치에 배치한다. `get`/`set` 중 어디에 계산하는 로직을 넣어야 할까 ? 어디에 넣을지 해깔리면 함수 이름에 계산한다는 사실을 표현해라.

### G18: 부적절한 static 함수
모든 정보를 인수에서 가져온다면 `static`으로 선언한다. 하지만 함수를 재정의할 가능성이 존재한다면 인스턴스 메서드로 선언해라. 조금 의심스럽다면 인스턴스 함수로 정의해라. 그래도 static으로 하고 싶으면 제정의할 가능성이 없는지 꼼곰히 따져봐라.

### G19: 서술적 변수
서술적인 변수 이름은 많이 써도 괜찮다. 많은수록 좋다. 계산 중간값에 좋은 이름만 붙여도 해석이 쉬워진다.

### G20: 이름과 기능이 일치하는 함수
Date newData = date.add(5)
5일을 더하나 ? 5주 ? 5시간인가 ?
date 인스턴스를 변경하나 ? 아님 그대로 두고 새로운 Date를 반환하나 ?
코드만으로는 알 수가 없다.

더 좋은 이름으로 바꾸던가, 더 좋은 이름을 붙이기 쉽게 기능을 정리해라.

### G21: 알고리즘을 이해하라
실제 알고리즘을 고민하지 않으면 여기저기 if문과 flag를 넣게된다. 돌아가는 것, 테스트 케이스를 통과했다는 사실만으로는 부족하다. 알고리즘이 올바르다는 사실을 확인하고 이해하려면 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고다.

### G22: 논리적 의존성은 물리적으로 드러내라
논리적인 의존성만으로는 부족하다. 물리적으로 의존해라. HolydayReporter안에 PAGE_SIZE라는 const 변수가 있는것은 논리적 의존이다. 다른 클래스에 해당 변수를 넣어두고 `getMaxPageSize()` 함수로 호출하는 것이 더 적절하다.

### G23: If/Else, Switch/Case 보다는 다형성을 사용하라
switch문 하나 규칙을 지켜라. 선택 유형 하나에는 switch문을 한번만 사용한다. 같은 선택을 수행하는 다른 코드가 필요하면 다형성 객체를 생성해라.

switch문 사용은 올바른 결정이 아니라 가장 쉬운 결정이다.
하지만, 다형성은 코드 변경이 쉬운데, switch문은 더 복잡하다.

### G24: 표준 표기법을 따르라
팀은 업계 표준을 따라야 한다. 그러면 표준을 설명하는 문서를 만들 필요가 없다. 팀이 정한 표준은 팀원 모두가 따라야 한다.

### G25: 매직 숫자는 명명된 상수로 교체하라
단순한 숫자라도 그대로 쓰지말고 상수화 하라.

### G26: 정확하라
부동소수점으로 통화를 표현하는 행동은 거의 범죄에 가깝다. 갱신한 가능성이 희박하다고 `lock/transaction` 관리를 건너뛰는건 게으름이다. `List`로 선언할 변수를 `ArrayList`로 선언하는 행동은 지나친 제약이다.
코드에서 뭔가를 결정할 때는 정확히 결정한다. 대충 결정해서는 안된다. `null`을 봔한할지 모르겠다며 체크하고, 결과가 1개라 짐작된다면 확실히 확인하라.

### G27: 관례보다 구조를 사용하라
명명관례보다는 구조적인 강제가 더 좋다. `enum` + `switch/case` 문보다는 추상 메서드가 있는 기초 클래스가 더 좋다.

### G28: 조건을 캡슐화하라
논리식(if/while의 괄호절 안의 내용)은 이해하기 어렵다. 조건의 의도를 분명히 밝히는 함수로 표현하라.

### G29: 부정 조건은 피하라
부정은 긍정보다 이해하기 어렵다.

### G30: 함수은 한 가지만 해야 한다
함수를 짜다보면 일련의 작업을 수행하고픈 유혹에 빠진다. 한 가지만 수행하는 좀 더 작은 함수 여럿으로 나눠야 마땅하다.

```java
public void pay() {
    for (Employee e: employees) {
        if (e.isPayDay()) {
            Money pay = e.calcuatePay();
            e.deliverPay(pay);
        }
    }
}
```
위 함수는 3가지 일을 한다.

직원 목록을 루프로 돌려,
각 직원의 월급일을 확인하고,
해당 직원에게 월급을 지급한다.

```java
public void pay() {
    for (Employee e: employees) {
        payIfNecessary(e)
    }
}

private void payIfNecessary(Employee e) {
    if (e.isPayDay()) {
        calculateAndDeliverPay(e);
    }
}

private void calculateAndDeliverPay(Employee e) {
    Money pay = e.calcuatePay();
    e.deliverPay(pay);
}
```

### G31: 숨겨진 시간적인 결합
시간적인 결합을 숨겨서는 안 된다. 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러낸다. 선행되어야 하는 함수에서 뒤에 실행할 함수에 필요한 인수를 반환하도록 코드를 짜라.

### G32: 일관성을 유지하라
코드 구조를 잡을 때는 이유를 고민하고, 그 이유를 코드 구조로 명백히 표현하라. 구조에 일관성이 없어 보이면 남들이 마음대로 바꿔도 괜찮다고 생각한다. 일관성이 보인다면 남들도 그걸 따르고 보존한다.

### G33: 경계 조건을 캡슐화하라
경계 조건은 빼먹거나 놓치기 쉽다. 한 곳에서 별도로 처리해서 코드 여기저기서 처리하지 않아도 되게하라.

### G34: 함수는 추상화 수준을 한 단계만 내려가야 한다
함수 내 모든 문장은 추상화 수준이 동일해야 한다. 그리고 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다.

### G35: 설정 정보는 최상위 단계에 둬라
추상화 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨겨서는 안 된다. 최상위 단계에 뒤야 변경하기도 쉽다.

### G36: 추이적 탐색을 피하라
일반적으로 한 모듈은 주변 모듈을 모를수록 좋다. A가 B를 사용하고 B가 C를 사용할 경우 A는 C를 알 필요가 없다. 이를 디미터의 법칙<sup>Law of Demeter</sup> 또는 부끄럼 타는 코드<sup>Writing Shy Code</sup>라고도 한다. `a.getB().getC().getValue()` 같은 코드가 있다면 C에 Q를 끼워넣을 때 해당 코드들을 모두 찾아서 고쳐야 한다.

## Java
### J1: 긴 import 목록을 피하고 와일드카드를 사용하라
패키지에서 클래스 둘 이상을 사용한다면 와일드카드(*)를 사용하라.

(JavaScript 에서는 번들 크기가 무조건 작은게 이득이므로 `Dynamic import` 및 필요한 모듈만 빼서 사용하자)

### J2: 상수는 상속하지 않는다
상수가 어디서 왔는지 찾는다고 `interface` 나 부모 클래스를 찾아보는건 끔찍하다. 대신 `static import`를 사용하라.

### J3: 상수 대 Enum
`enum`은 이름이 부여된 열거체라서 훨씬 더 유연하고 강력하다.

## 이름
### N1: 서술적인 이름을 사용하라
소프트웨어 가독성의 90%는 이름이 결정한다.

### N2: 적절한 추상화 수준에서 이름을 선택하라
구현을 드러내는 이름을 피하라. 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택해라. 인간은 추상화 수준을 뒤섞는 능력이 너무나도 뛰어나다.

### N3: 가능하다면 표준 명명법을 사용하라
패턴이름, 각 언어의 toString, 프로텍트에 유효한 의미가 담긴 이름을 많이 사용할수록 독자가 코드를 이해하기 쉬워진다.

### N4: 명확한 이름
목적을 명확히 밝히는 이름을 선택한다.

### N5: 긴 범위는 긴 이름을 사용하라
범위가 작으면 아주 짧은 이름을 사용해도 괜찮다. 범위가 5줄 안팎이라면 i, j와 같은 이름도 괜찮다.

### N6: 인코딩을 피하라
`m_`, `f`와 같은 접두어는 필요없다. 헝가리언 표기법의 오염에서 이름을 보호하라.

### N7: 이름으로 부수 효과를 설명하라
`getOos()`에서는 `ObjectOutputStream`을 가져오기만 해야할뿐 새로 생성해서는 안된다. 그럴려면 `createOrReturnOos()`라는 이름이 더 좋다.

## 테스트
### T1: 불충분한 테스트
잠재적으로 깨질 만한 부분은 모두 테스트해야 한다.

### T2: 커버리지 도구를 사용하라!
테스트가 불충분한 곳을 찾기 쉬워진다. 전혀 실행되지 않는 `if` 혹은 `case`가 금방 드러난다.

### T3: 사소한 테스트를 건너뛰지 마라
### T4: 무시한 테스트는 모호함을 뜻한다
불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 `@Ignore`를 붙여 표현한다.

### T5: 경계 조건을 테스트하라
여기에서 실수하는 경우가 흔하다.

### T6: 버그 주변은 철저히 테스트하라
버그는 서로 모이는 경향이 있다. 버그를 발견했다면 해당 함수를 철저히 테스트해라. 다른 버그도 발견하리라.

### T7: 실패 패턴을 살펴라
합리적인 순서로 정렬된 꼼꼼한 테스트 케이스는 실패 패턴을 드러낸다. 간단한 예로 5자를 넘기는 모든 테스트가 실패한다면? 인수로 음수가 들어온 경우 테스트 케이스가 실패한다면 ?

### T8: 테스트 커버리지 패턴을 살펴라
통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트의 원인이 드러난다.

### T9: 테스트는 빨라야 한다
일정이 촉박할 경우 테스트가 느리면 건너뛰기 쉽다.


감사합니다!